### **算法题目：求单变量数据集的众数（Mode）**

**题目描述：**  
给定一个包含整数的单变量数据集（以std::vector形式存储），设计一个算法来计算该数据集的众数。如果存在多个众数，请返回所有众数的列表。如果数据集中所有值出现次数相同，则返回空列表。

**输入：**  
一个整数向量 `data`，例如 `{2, 3, 3, 4, 5, 5, 5, 6, 7}`。

**输出：**  
一个包含众数的向量，例如 `{5}`。如果存在多个众数，返回所有众数的向量，例如 `{2, 3}`。如果没有众数，返回空向量 `{}`。

**示例：**  
1. 输入：`data = {2, 3, 3, 4, 5, 5, 5, 6, 7}`  
   输出：`{5}`  
2. 输入：`data = {1, 2, 2, 3, 3}`  
   输出：`{2, 3}`  
3. 输入：`data = {1, 2, 3, 4, 5}`  
   输出：`{}`  

---

### **代码框架**

请实现函数`find_modes`。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

std::vector<int> find_modes(const std::vector<int>& data) {
    return modes;
}

// 测试用例
int main() {
    std::vector<std::pair<std::vector<int>, std::vector<int>>> test_cases = {
        {{2, 3, 3, 4, 5, 5, 5, 6, 7}, {5}},
        {{1, 2, 2, 3, 3}, {2, 3}},
        {{1, 2, 3, 4, 5}, {}},
        {{1, 1, 2, 2, 3, 3, 4, 4}, {1, 2, 3, 4}},
        {{}, {}}
    };

    for (size_t i = 0; i < test_cases.size(); ++i) {
        const auto& [data, expected] = test_cases[i];
        std::vector<int> result = find_modes(data);

        // 检查结果是否正确
        std::sort(result.begin(), result.end());
        std::sort(expected.begin(), expected.end());
        assert(result == expected);

        std::cout << "Test case " << i + 1 << " passed: ";
        for (int num : result) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }

    std::cout << "All test cases passed!" << std::endl;
    return 0;
}
```
