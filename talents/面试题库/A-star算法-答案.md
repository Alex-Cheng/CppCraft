# ç®€åŒ–ç‰ˆï¼ˆåªè¿”å›è·¯å¾„é•¿åº¦ï¼‰

```
int aStarSearch(const vector<vector<int>>& grid,
                pair<int,int> start,
                pair<int,int> goal) 
{
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> gScore(n, vector<int>(m, INT_MAX));
    vector<vector<bool>> closed(n, vector<bool>(m, false));

    priority_queue<Node, vector<Node>, greater<Node>> open;

    int sx = start.first, sy = start.second;
    int gx = goal.first, gy = goal.second;

    gScore[sx][sy] = 0;
    open.push({sx, sy, 0, heuristic(sx, sy, gx, gy)});

    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

    while (!open.empty()) {
        Node cur = open.top();
        open.pop();

        if (closed[cur.x][cur.y]) continue;
        closed[cur.x][cur.y] = true;

        // åˆ°è¾¾ç›®æ ‡
        if (cur.x == gx && cur.y == gy) {
            return cur.g;
        }

        for (auto& d : dirs) {
            int nx = cur.x + d[0], ny = cur.y + d[1];
            if (nx<0 || ny<0 || nx>=n || ny>=m) continue;
            if (grid[nx][ny] == 1) continue;

            int newG = cur.g + 1;
            if (newG < gScore[nx][ny]) {
                gScore[nx][ny] = newG;
                int h = heuristic(nx, ny, gx, gy);
                open.push({nx, ny, newG, h});
            }
        }
    }
    return -1; // ä¸å¯è¾¾
}
```

# å®Œæ•´ç‰ˆï¼ˆå¸¦è·¯å¾„æ¢å¤ï¼‰
```
int aStarSearch(const vector<vector<int>>& grid,
                pair<int,int> start,
                pair<int,int> goal) 
{
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> gScore(n, vector<int>(m, INT_MAX));
    vector<vector<pair<int,int>>> parent(n, vector<pair<int,int>>(m, {-1,-1}));
    vector<vector<bool>> closed(n, vector<bool>(m, false));

    priority_queue<Node, vector<Node>, greater<Node>> open;

    int sx = start.first, sy = start.second;
    int gx = goal.first, gy = goal.second;

    gScore[sx][sy] = 0;
    open.push({sx, sy, 0, heuristic(sx, sy, gx, gy)});

    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

    while (!open.empty()) {
        Node cur = open.top();
        open.pop();

        if (closed[cur.x][cur.y]) continue;
        closed[cur.x][cur.y] = true;

        // åˆ°è¾¾ç›®æ ‡ï¼Œæ¢å¤è·¯å¾„
        if (cur.x == gx && cur.y == gy) {
            vector<pair<int,int>> path;
            int x = gx, y = gy;
            while (x != -1 && y != -1) {
                path.push_back({x,y});
                auto p = parent[x][y];
                x = p.first; y = p.second;
            }
            reverse(path.begin(), path.end());

            cout << "è·¯å¾„: ";
            for (auto [px,py] : path) {
                cout << "(" << px << "," << py << ") ";
            }
            cout << endl;

            return cur.g;
        }

        for (auto& d : dirs) {
            int nx = cur.x + d[0], ny = cur.y + d[1];
            if (nx<0 || ny<0 || nx>=n || ny>=m) continue;
            if (grid[nx][ny] == 1) continue;

            int newG = cur.g + 1;
            if (newG < gScore[nx][ny]) {
                gScore[nx][ny] = newG;
                parent[nx][ny] = {cur.x, cur.y};
                int h = heuristic(nx, ny, gx, gy);
                open.push({nx, ny, newG, h});
            }
        }
    }
    return -1; // ä¸å¯è¾¾
}
```

# è¿½é—®é—®é¢˜

## ğŸ”¹ 1. A\* å’Œ Dijkstra çš„å…³ç³»ï¼Ÿ

**é¢è¯•å®˜å¯èƒ½é—®**ï¼šA\* å’Œ Dijkstra æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ
**ç­”æ¡ˆæç¤º**ï¼š

* Dijkstra æ˜¯ A\* çš„ç‰¹ä¾‹ï¼Œç­‰ä»·äº A\* ä½¿ç”¨ **å¯å‘å¼ h(n)=0** çš„æƒ…å†µã€‚
* A\* = g(n) + h(n)ï¼ˆä»£ä»· + å¯å‘ï¼‰ï¼Œè€Œ Dijkstra åªç”¨ g(n)ã€‚
* æ‰€ä»¥ Dijkstra æ›´é€šç”¨ï¼Œä½†æ•ˆç‡æ›´ä½ã€‚

---

## ğŸ”¹ 2. å¯å‘å‡½æ•° h(n) è¦æ»¡è¶³ä»€ä¹ˆæ€§è´¨ï¼Ÿ

**é¢è¯•å®˜å¯èƒ½é—®**ï¼šA\* çš„å¯å‘å¼éœ€è¦æ»¡è¶³ä»€ä¹ˆæ¡ä»¶ï¼Œæ‰èƒ½ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£ï¼Ÿ
**ç­”æ¡ˆæç¤º**ï¼š

* **Admissibleï¼ˆå¯é‡‡çº³æ€§ï¼‰**ï¼šh(n) â‰¤ n åˆ°ç›®æ ‡çš„å®é™…æœ€å°ä»£ä»·ã€‚
* **Consistentï¼ˆå•è°ƒæ€§ï¼‰**ï¼šh(n) â‰¤ cost(n, nâ€™) + h(nâ€™)ã€‚
* å¦‚æœæ»¡è¶³ consistentï¼Œåˆ™ä¹Ÿä¸€å®šæ˜¯ admissibleã€‚

---

## ğŸ”¹ 3. A\* çš„æ—¶é—´å¤æ‚åº¦ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* æœ€åæƒ…å†µï¼šO(E)ï¼ˆå’Œ Dijkstra ç±»ä¼¼ï¼ŒE ä¸ºè¾¹æ•°ï¼‰ã€‚
* å®é™…æƒ…å†µï¼šæ•ˆç‡å–å†³äºå¯å‘å‡½æ•°çš„å¥½åã€‚
* å¯å‘è¶Šç²¾å‡†ï¼Œè¶Šæ¥è¿‘ç›®æ ‡ï¼Œæ‰©å±•çš„èŠ‚ç‚¹è¶Šå°‘ã€‚

---

## ğŸ”¹ 4. A\* çš„ç©ºé—´å¤æ‚åº¦ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* O(V)ï¼Œå› ä¸ºè¦ç»´æŠ¤ open set / closed setã€‚
* åœ¨å¤§å›¾æˆ–ä¸‰ç»´ç½‘æ ¼ä¸­ï¼Œå†…å­˜æ¶ˆè€—å¯èƒ½æ˜¯ç“¶é¢ˆã€‚

---

## ğŸ”¹ 5. å¦‚æœå¯å‘å‡½æ•°è¿‡å¤§ï¼Œä¼šæ€æ ·ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* å¦‚æœ h(n) **é«˜ä¼°** äº†å®é™…ä»£ä»·ï¼ŒA\* ä¸å†ä¿è¯æœ€ä¼˜ã€‚
* ä½†æ•ˆç‡å¯èƒ½æ›´é«˜ï¼ˆæ›´æ¥è¿‘ Greedy Best-First Searchï¼‰ã€‚
* å·¥ç¨‹é‡Œæœ‰æ—¶ä¼šæ•…æ„æ”¾å®½æœ€ä¼˜æ€§ï¼Œæ¢å–æ€§èƒ½ã€‚

---

## ğŸ”¹ 6. å¦‚ä½•å¤„ç†åŠ¨æ€éšœç¢ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* é‡æ–°è¿è¡Œ A\*ï¼ˆä»£ä»·é«˜ï¼‰ã€‚
* ç”¨ **D* Lite*\* æˆ– **LPA\*** è¿™ç§å¢é‡æœç´¢ç®—æ³•ï¼Œèƒ½åœ¨éšœç¢å˜åŒ–æ—¶é«˜æ•ˆæ›´æ–°è·¯å¾„ã€‚
* å·¥ç¨‹ä¸­å¸¸ç”¨åœ¨æœºå™¨äººå¯¼èˆªã€æ¸¸æˆ AIã€‚

---

## ğŸ”¹ 7. Open Set ç”¨ä»€ä¹ˆæ•°æ®ç»“æ„ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* é€šå¸¸ç”¨ **ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰**ï¼ŒæŒ‰ f(n)=g(n)+h(n) æ’åºã€‚
* æ’å…¥å’Œå–æœ€å°å€¼æ˜¯ O(log n)ã€‚
* å¦‚æœç”¨æ™®é€š listï¼Œæ¯æ¬¡æ‰¾æœ€å°å€¼æ˜¯ O(n)ã€‚

---

## ğŸ”¹ 8. å¦‚ä½•æ£€æµ‹å¹¶é¿å…â€œéæµå½¢â€è·¯å¾„ï¼ˆæ¯”å¦‚åœ¨ 3D ç½‘æ ¼å¯¼èˆªä¸­ï¼‰ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* åœ¨ç”Ÿæˆé‚»å±…æ—¶ï¼Œæ£€æŸ¥å‡ ä½•åˆæ³•æ€§ï¼ˆå¦‚æ˜¯å¦ç©¿è¶Šéšœç¢ï¼‰ã€‚
* ç”¨ **å¯¼èˆªç½‘æ ¼ï¼ˆNavMeshï¼‰** æ›¿ä»£è§„åˆ™æ ¼å­ï¼Œå¯ä»¥å‡å°‘éæµå½¢è·¯å¾„ã€‚
* å·¥ç¨‹åº”ç”¨é‡Œç»å¸¸ç»“åˆå‡ ä½•æ‹“æ‰‘æ£€æŸ¥ã€‚

---

## ğŸ”¹ 9. å¦‚æœè¦åœ¨å¤§è§„æ¨¡åœ°å›¾ï¼ˆæ¯”å¦‚å‡ ç™¾ä¸‡èŠ‚ç‚¹ï¼‰ä¸Šè¿è¡Œ A\* æ€ä¹ˆä¼˜åŒ–ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* ä½¿ç”¨ **åˆ†å±‚ A**\*ï¼ˆHierarchical A\*ï¼ŒHPA\*ï¼‰ã€‚
* ç”¨ **åŒå‘ A**\*ï¼ˆä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶æœç´¢ï¼‰ã€‚
* ç”¨ **Jump Point Search (JPS)** åœ¨ç½‘æ ¼ä¸­è·³è¿‡å†—ä½™èŠ‚ç‚¹ã€‚
* ç”¨ **å†…å­˜ä¼˜åŒ–çš„æ•°æ®ç»“æ„**ã€‚

---

## ğŸ”¹ 10. é¢è¯•å®˜æœ€åå¯èƒ½é—®ï¼šèƒ½æ‰‹å†™ä¸€ä¸ªä¾‹å­ï¼Œèµ°ä¸€é A\* è¿‡ç¨‹å—ï¼Ÿ

**ç­”æ¡ˆæç¤º**ï¼š

* å‡†å¤‡ä¸€ä¸ª 5x5 ç½‘æ ¼ï¼Œèµ·ç‚¹ (0,0)ï¼Œç»ˆç‚¹ (4,4)ï¼Œä¸­é—´æ”¾ 2 ä¸ªéšœç¢ã€‚
* æ¼”ç¤º open set / closed set çš„å˜åŒ–ã€‚
* å±•ç¤ºæœ€ç»ˆè·¯å¾„æ¢å¤ã€‚
  ğŸ‘‰ è¿™ä¸ªç¯èŠ‚è€ƒå¯Ÿä½ æ˜¯å¦èƒ½â€œèµ°æµç¨‹â€ï¼Œè€Œä¸æ˜¯æ­»è®°ç¡¬èƒŒã€‚

# é€ŸæŸ¥è¡¨
ğŸ‘Œ é‚£æˆ‘å¸®ä½ æ•´ç†ä¸€ä»½ **A\* é¢è¯•é€ŸæŸ¥å¡ï¼ˆCheat Sheetï¼‰**ï¼Œå†…å®¹ç²¾ç®€ã€å¯¹ç…§å¼ï¼Œæ–¹ä¾¿ä½ é¢è¯•å‰ 3\~5 åˆ†é’Ÿå¿«é€Ÿå¤ä¹ ã€‚

---

# ğŸš€ A\* é¢è¯•é€ŸæŸ¥å¡

## 1. åŸºç¡€å…¬å¼

* f(n) = g(n) + h(n)

  * g(n): ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„å®é™…ä»£ä»·
  * h(n): å¯å‘å¼ï¼ˆå½“å‰èŠ‚ç‚¹åˆ°ç»ˆç‚¹çš„ä¼°è®¡ä»£ä»·ï¼‰

---

## 2. ä¸ Dijkstra çš„å…³ç³»

* Dijkstra = A\* + **h(n)=0**
* æ‰€ä»¥ A\* æ›´é«˜æ•ˆï¼Œä½†ä¾èµ–å¯å‘å‡½æ•°

---

## 3. å¯å‘å‡½æ•°è¦æ±‚

* **Admissible**ï¼ˆå¯é‡‡çº³æ€§ï¼‰ï¼šh(n) â‰¤ å®é™…æœ€å°ä»£ä»· â†’ ä¿è¯æœ€ä¼˜
* **Consistent**ï¼ˆå•è°ƒæ€§ï¼‰ï¼šh(n) â‰¤ cost(n,nâ€™) + h(nâ€™) â†’ ä¿è¯æ”¶æ•›

å¸¸è§å¯å‘ï¼š

* ç½‘æ ¼ Manhattan è·ç¦»
* æ¬§å‡ é‡Œå¾—è·ç¦»
* å¯¹è§’è·ç¦»

---

## 4. å¤æ‚åº¦

* æ—¶é—´ï¼šO(E)ï¼Œå–å†³äºå¯å‘å‡½æ•°å¥½å
* ç©ºé—´ï¼šO(V)ï¼Œéœ€ç»´æŠ¤ open set + closed set

---

## 5. ç‰¹æ®Šæƒ…å†µ

* **h(n) å¤ªå°** â†’ é€€åŒ–æˆ Dijkstra
* **h(n) å¤ªå¤§ï¼ˆé«˜ä¼°ï¼‰** â†’ ä¸ä¿è¯æœ€ä¼˜ï¼Œä½†æ›´å¿«
* **åŠ¨æ€éšœç¢** â†’ ç”¨ D\* Lite æˆ– LPA\*

---

## 6. å¸¸ç”¨ä¼˜åŒ–

* Open set ç”¨ **ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰**
* **åŒå‘ A**\*ï¼šèµ·ç‚¹ã€ç»ˆç‚¹åŒæ—¶æœç´¢
* **Jump Point Search (JPS)**ï¼šåœ¨ç½‘æ ¼ä¸ŠåŠ é€Ÿ
* **åˆ†å±‚ A**\* (HPA\*)ï¼šå¤§åœ°å›¾åˆ†å—

---

## 7. å·¥ç¨‹å®è·µ

* æ¸¸æˆ AI â†’ NavMesh + A\*
* æœºå™¨äºº â†’ A\* + D\* Lite
* GIS / BIM â†’ ä¸å‡ ä½•æ‹“æ‰‘ç»“åˆï¼Œé¿å…éæµå½¢è·¯å¾„

---

## 8. å¸¸è§è¿½é—®ï¼ˆé™„ç­”æ³•ï¼‰

* **A* æ‰¾ä¸åˆ°æœ€ä¼˜è§£çš„æƒ…å†µï¼Ÿ*\* â†’ å¯å‘å‡½æ•°ä¸æ»¡è¶³ admissible
* **å¦‚ä½•æ¢å¤è·¯å¾„ï¼Ÿ** â†’ ç”¨ `cameFrom` å­—å…¸å›æº¯
* **ä¸ºä»€ä¹ˆéœ€è¦ closed setï¼Ÿ** â†’ é¿å…é‡å¤è®¿é—®èŠ‚ç‚¹
* **å¦‚ä½•åœ¨ç™¾ä¸‡èŠ‚ç‚¹åœ°å›¾ä¸ŠåŠ é€Ÿï¼Ÿ** â†’ HPA\* / JPS / åŒå‘ A\*

---

## 9. å¿«é€Ÿæ¼”ç¤ºï¼ˆä¾‹å­ï¼‰

5x5 ç½‘æ ¼ï¼Œèµ·ç‚¹ (0,0)ï¼Œç»ˆç‚¹ (4,4)ï¼Œæœ‰éšœç¢ï¼š

* f = g+h
* open set åˆå§‹ï¼š\[(0,0)]
* æ‰©å±• â†’ (1,0)ã€(0,1) â€¦
* æœ€ç»ˆè·¯å¾„æ¢å¤ï¼š\[(0,0)â†’(1,0)â†’(2,0)â†’(3,0)â†’(4,0)â†’(4,1)â€¦(4,4)]

---

âš¡ **ä½¿ç”¨å»ºè®®**

* é¢è¯•æ—¶å…ˆå®ç° **ç®€ç‰ˆï¼ˆè¿”å›è·¯å¾„é•¿åº¦ï¼‰**
* å¦‚æœæœ‰æ—¶é—´ â†’ åŠ ä¸Š **è·¯å¾„æ¢å¤**
* æœ€åå›ç­”ï¼šA\* å¯æ‰©å±•åˆ° **å¤§åœ°å›¾ / åŠ¨æ€ç¯å¢ƒ**
